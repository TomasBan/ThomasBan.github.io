---
layout: post
title: 算法学习日志1——罗马数字转整数
date: 2019-06-10 18:20:41.000000000 +09:00
---

## 题目描述

```
罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
```

## 思考过程

- 想法1：暴力匹配每个字母，没错匹配后面的数字大于前面的数字，如果是做相对应的变形；
- 想法2：在按照想法一的思考过程进行编码的时候，突发奇想：V是等于5的，如果V前面带了一个I那么等于 5 - 1 = 4，如果按照整个序列的字母进行累加，那么遇到后面的数字比前面的大，那么应该减去前面的数字的两倍的数值就可以了。接着类推所有的特殊情形，刚好符合这种规律。

## 代码实现

```
func RomantoInt(roman string) int{

	res := 0

	numHash := map[byte]int{
		'I' : 1,
		'V' : 5,
		'X' : 10,
		'L' : 50,
		'C' : 100,
		'D' : 500,
		'M' : 1000,
	}

	var arr = []byte(roman)

	for index,_ := range arr {

		fmt.Println(arr[index])
		if ( index > 0 && ( numHash[arr[index]] > numHash[arr[index - 1]] ) ){
			res += numHash[arr[index]] - 2 * numHash[arr[index -1]]
		}else{
			res += numHash[arr[index]]
		}

	}

	return res
}
```
## 思考与总结

想思考再动手。在草稿上面进行演算一下，找一下规律这个是必须的，如果直接写代码的话，往往会缺少思考很多边界的条件，所以先思考在动手写代码很重要。