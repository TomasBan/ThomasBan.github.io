---
layout: post
title: 算法学习日志2——最长公共前缀
date: 2019-06-17 17:13:50.000000000 +09:00
tags: 算法
---

## 题目描述

>题目均来自leetcode:[最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

```
编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

示例 1:

输入: ["flower","flow","flight"]
输出: "fl"
示例 2:

输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
说明:

所有输入只包含小写字母 a-z
```

## 思考过程

- 在进行题目分析的时候：那就是通过第一个元素的第一个字母去匹配后面每一个元素的对位的字母，如果全部匹配那么匹配第二个字母，以此类推。如果碰到无法匹配的，那就返回从0到前一成功匹配字母脚标的子字符串；
- 利用语言特性，利用语言的string库，查找前缀的函数进行查找。

但是在思考的时候，发现要生成字符串的子串太麻烦，还是用第一种方式进行解决。


## 代码实现

```
func LongestCommonPrefix(strs []string) string {

	if(len(strs) == 0){
		return ""
	}

	if len(strs) == 1 {
		return strs[0]
	}

	if len(strs[0]) == 0 {
		return ""
	}

	temp := -1
	first := strs[0]
Loop:
	for i := 0; i < len(first); i++ {
		for index,item := range strs {
			if index == 0 {
				continue
			}
			if len(item) <= i {
				break
			}
			if item[i] != first[i] {
				break Loop
			}
			if index == arrLen - 1 {
				temp = i
			}
		}
	}
	if temp < 0 {
		return ""
	}
	return strs[0][0:temp+1]
}
```

在上面的代码里面，对了几种特殊的情况直接返回特例。相当于减少了算法的思考难度。在提交，进行测试的时候，发现有部分代码有bug，所以引入信号量的机制来终结整个循环。

## 思考与总结

在解决这道题目的时候，提交了8次，通过了1次。复盘整个过程，有几个点需要记录下来：
1. 在思考的时候只用了几分钟，代码的边际范围没有确定好，没有考虑到空元素，空数组的问题；
2. 代码没有一开始做好单元测试，导致很多重复的测试用例重复错误；
3. `Golang`里面的`break`关键字没有理解好，`break`只是终结本循环体，并不会跳出外层的循环体。
4. 在`Golang`中，可以用标签的形式跳出外层的循环。